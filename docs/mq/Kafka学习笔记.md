
Kafka 是 LinkedIn(领英) 开发的，前期主要用于处理海量的日志。

官网： http://kafka.apache.org/intro

Bilibili: https://www.bilibili.com/video/av65544753?from=search&seid=17708076357179732776

## 简介

Kafka 是一个分布式的流式平台。

- 发布订阅消息流，类似消息队列
- 可以容错的持久化方式
- 提供完整的流式处理类库，实时处理流失数据

重点突出： real-time 实时

## 应用场景

- 消息队列 ： 建立实时流数据管道，可靠的在系统和应用程序之间获取数据。
- 数据处理： 构建实时的数据处理程序来转换或处理数据流。

## APIS

- Producer API 允许 应用程序 向 Kafka 中发布 一个或 多个 topic 的消息
- Consumer API 允许 应用程序订阅一个或多个主题 然后处理这些流式数据
- Streams  API 允许 应用程序 作为 流的处理器，消费从一个或者多个主题输入流，生产一个或者多个主题的数据流，高效进行 输入流 到 输出流的转换。
- Connector API 允许 构建和运行可重用的生产者或消费者，将Kafka主题连接到现有的应用程序或数据系统。例如，到关系数据库的连接器可能捕获对表的每个更改。

Kafka 通信底层使用的 TCP, 官方提供多版本语言的 Client.

## topic

抽象核心概念 topic.主题是 发布者提供的一种类别区分。一个主题下面经常有多个订阅这。

对于每个 topic ，Kafka集群主要 使用向下面这种分区日志 。topic 的结构如下图：

![topic内部结构](./images/kafka-1.png)


通过上图可以看出，每个 分区 都是 不可变 有序的，数据会被持续的追加到这个结构体中。每一条在 分区中的数据会被分配一个叫作 `offset` 偏移量的序列号，可以唯一的标识在 分区中的位置。

Kafka 集群会`持久的保留所有的 数据记录`，不管这条记录有没有被消费。这个是可以配置 周期的。比如说，配置的周期是 2 天， 发布 消息 2天内可以被 消费者消费，超过 就会被 丢弃 掉来 释放空间。

![topic内部结构](./images/kafka-2.png) 

注意 两位数字 是 整数。刚开始看错成 二进制。

在 消费者 上存储的唯一的元数据 是 `offset` 。每个消费者 的 offset 是`由消费者自己控制的`。消费者可以随意的去控制 这个 offset 。正常的就是线性的按照顺序增加。但是 它也可以随意的改变这个值或者 跳过某些 offset直接读取最新的记录。

消费者的创建比较随意，与 集群的耦合度比较低。你可以使用命令行工具 tail 任何 主题的内容。

## 分布式

日志的分区 分布在 Kafka 集群中的服务器上，每个服务器处理数据 和 共享分区的请求。为了容错，每个分区被复制到大量可配置的服务器上。 每个分区有个 Leader 和多个 Follower服务器。  Leader 处理分区所有的 读 和 写 请求，而 follower 被动的复制 leader的数据。如果 leader 挂掉，那么 就会在 Follower选举出新的leader。

## Geo_Replication

地理相关的复制。这个暂时不做翻译。

## Producers

生产者 发布与 主题相关的消息，它负责选择将哪些记录分配给主题中的哪个分区，这个可以通过某些算法 轮询的进行完成，便于负载均衡。

## Consumers

消费者使用 组名 `group name` 标记自己，每条消息传递到消费者手中，通过 消费者订阅的组名。（应该就是一种标识）。消费者的进程可以是个单独的进程，或者单独的集器。如果所有的消费者 具有相同的 组名 `have the same consumer group` 那么这个数据会高效在这些 消费者上面进行 负载均衡。

![topic内部结构](./images/kafka-3.png) 

由上图可见，两个服务器组成了具有 4个 分区的（P0-P3），和两个 消费者组的集群。消费者组 A有两个实例，B具有4个实例。

Kafka 中实现消费的方式在 日志中划分分区，这样每个实例在任何时候都是 分区“公平共享” 的唯一消费者，这个保持组成成员的身份是由 Kafka协议动态处理的。如果有新的实例加入组，它们将从组的其他成员那里接管一些分区。如果一个实例 dead,它的分区将分配给其他的实例。

Kafka 只提供分区内记录的总顺序，而不提供主题中不同分区之间的总顺序。大于大部分应用程序来说，按照分区排序和按键分区数据能力已经足够了。如果需要记录总顺序，则可以使用 主题 只有一个分区来实现这一点，尽快这意味着，只有一个 consumer 进程。

## Guarantees 保证

kafka 提供以下保证：
1. 生产者发送到 特定 主题分区的消息将按照 发送的顺序追加。如果记录M1是由与记录M2相同的生产者发送的，并且M1是先发送的，那么M1的偏移量将比M2低，并出现在日志的前面。
2. 消费者 看到的就是 日志存储的 按照顺序的记录
3. 对于 N 台服务器，（单个主题的复制），允许 N-1 台服务器故障

## Kafka 作为 消息系统 与传统消息队列的对比

Kafka 的流式概念 与传统的消息队列有什么不同？

传统的消息传递有两种模式： 队列 模式 和 发布订阅模式。 在队列模式中，消费者消费者 从一台服务器中读取数据。在发布订阅模式中，消息被广播给所有的消费者。

Kafka中的消费者群体概念概括了这两个概念。与队列一样，消费者组允许您将处理划分到一组进程(消费者组的成员)上。与发布-订阅一样，Kafka允许您向多个消费者组广播消息。

Kafka模型的优点是每个主题都有这两种属性——它可以扩展处理，而且是多订阅者的——没有必要选择其中之一。

传统队列在服务器上按顺序保留记录，如果多个使用者从队列中消费，则服务器按存储记录的顺序分发记录。

然而，尽管服务器按顺序分发记录，但这些记录是异步传递给使用者的，因此它们可能在不同的使用者上不按顺序到达。这实际上意味着记录的顺序在并行使用时丢失。消息传递系统通常通过“独占消费者”的概念来解决这个问题，该概念只允许一个进程从队列中消费，


## Kafka as a Storage System

-- 暂停。 http://kafka.apache.org/intro
