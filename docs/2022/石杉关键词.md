
## volatile
1. 内存可见性 -> 主存 /（本地高速缓存） 工作内存 保证修改之后立刻强制刷新回去，但是不保证 并发操作
2. 防止指令重排序 -> 单例模式
3. 强制过期 -> 太频繁也不好 -> 并发修改还是要 sych, relock等等

## CAS
1. AutomicInter -> CAS -> 无锁 -> compare And set -> ABA-> 引用地址version
2. data.incrementAndGet();
3. CAS 不要台频繁，空转影响CPU-> 分段 -> LongAdder
4. 分段CAS
## AQS
Abstract Queued Synchronize
ReentrantLock 底层使用， 队列+ state+thread 非公平锁
AQS 就是⼀个并发包的基础组件，⽤来实现各种锁，各种同步组件的。它包含 了 state 变量、加锁线程、等待队列等并发中的核⼼组件

## 读写锁优化
1. copy on write 

## 如何减少磁盘压力
1. 两块内存空间，swap 交换 -> 异步刷入磁盘 NIO
2. 写内存 ，分段加锁，避免锁竞争
3. 双buff的问题 ——> 双 bloomfilter

## MQ 不丢消息？
1. 生产者 -> 投递到mq 保证落盘
    a. call back ack （confirm机制，持久化到磁盘之后就会call back）
    b. 投递之后写入到redis 中记录一下状态，继续执行
    c. 回调之后 修改状态或者继续重新投递,自己也轮询 超过一段时间还没ack的，重新投递
2. mq持久化落盘
3. consumer ack =-1 手动ack.

## 如何提升并发 数据写盘
1. 双buff 开辟两块内存空间
2. 缓存切换
3. 内存写入的锁机制 串行化问题 -> 分片 + 分段锁
4. 刷入磁盘的时候换锁，不要长时间占用一把锁

## 热点缓存
1. 假设10个缓存结点 ，每个结点能承载2w极限，但是 某个消息 突发流量增加，访问某个key。落在单台 缓存机器压力就会很大。
2. 怎么发现呢？
   a. 通过storm 流式计算大数据发现热点数据 -> 同步到zk -> 分配到各个slave
   b. zk -> 热点key可以加载到jvm本地缓存
3. 限流 熔断 -> 保护好缓存 和DB

## 高并发情况下 DB的设计
1. 磁盘IO/网络带宽/CPU负载/内存消耗
2. sharding-jdbc 
3. userID/itemID/ 1000张表，按照region
4. 除了分库分表，挂几个slave,读写分离

## 高并发架构？百万连接？
1. 长连接 -> 建立好之后 通信就行了
2. 4c8G 200个线程CPU负载就偏高了
3. Kafka 也会面临非常多的 producer和consumer 的长连接，他是怎么做的
  a. Reactor 多路复用模型
4. 搞一个acceptor 线程，基于底层操作系统，实现连接请求监听。
    processor线程分配N个连接，如果有请求过来 把他放入到请求队列中去
    后面的线程池工作线程 获取请求，处理请求，放入到响应队列 -> processor处理回去
## TCC?
1. Try Confirm Cancel -> 对于一些系统需要提过 cancel机制
2. 记录一些活动日志， 主要是记录一些状态
3. 实际工作业务中用的也比较少
 ## Redis分布式锁的实现原理
1. 加过期时间 
2. 自动续命 
3. 怎么优化分布式锁的性能
4. 库存超卖怎么处理呢
    a. 分段加锁呗，1000个数量分成 50个库存
    b. 分段CAS呗

## zk分布式锁的原理
1. 临时顺序结点
2. 对上一个顺序加某个结点的监听
3. 创建一个结点下的临时结点，如果自己不是第一个结点，则对上一个结点加监听

## 分布式存储
1. 集群分片，es, redis cluster
2. master + slave 的备份

## es
1. 倒排索引 -> 内容分词-> <分词,id list> -> 扫描倒排索引 
   a. index 相当于数据库表
   b. field, document （相当于record）
   c. shard -> replica

## 分布式id
1. 双buff + db 存储步长 + 预分配 
2. 雪花算法 -> instanceID from zk
3. 美团leaf算法

## 分布式系统
1. rpc通信
2. 分布式事务 tcc, rocketmq,
3. 分布式锁
4. 分布式缓存/搜索

## 消息中间件缺点
1. 复杂性提升，可用性降低。

## MQ稳定性
1. 关闭自动ACK，手动ACK.
2. 


## ES
1. doc -> field 相当于一条记录
2. shard支持横向扩展，存储更多的数据。-> 多个replica 分布在不同的机器上。primary shard 默认5个。
replica shard 随时可以修改默认1个。 5 主 5从
3. index -> DB， type-> table; document -> record
4. 多台机器启动es实例，分布式。索引 -> 会自动选择master节点。 master ,replica.主从切换.

## 高并发
1. 系统拆分/缓存/mq/分库分表/读写分离/es