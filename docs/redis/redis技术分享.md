# redis
 redis 分享草稿。
## 开头
 redis 属于我们日常工作常用的，非常熟悉的一块 缓存中间件。主要提供 缓存，分布式锁，mq,bloomfiter等操作。接下来我由浅入深的讲解一下redis的相关知识点，让我们知其然还要知其所以然，同类产品比如 memcache，localcache等。
## redis可以做什么
1. 记录帖子的点赞数、评论数和点击数 (hash)。
2. 记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。
3. 记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。
4. 缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。
5. 分布式锁/缓存/阻塞队列

## 基础数据结构
常用的5种基础数据结构。
### string
1. string 字符串的应用非常普遍，比如我们存储的用户信息，可以在应用程序中 toJson序列化之后 进行存储，同样，取出数据的时候进行一次反序列化的过程。string底层是使用 SDS(Simple Dynamic String) 动态扩容的字符串构成的。

![redis string](./images/s-redis-1.png) 

Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字 符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时， 扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是 字符串最大长度为 512M。 相比c 原生的获取len的时候不用遍历，不用处理结束符的问题。

```c
struct SDS<T> {
    T capacity; // 数组容量  预分配+懒回收 避免频繁的回收数据和分配空间
    T len; // 数组长度
    byte[] content; // 数组内容
}
```

键值对
```
    > set name codehole OK
    > get name "codehole"
    > exists name
    (integer) 1
    > del name
    (integer) 1
    > get name
    (nil)
```
批量键值对
可以批量对多个字符串进行读写，节省网络耗时开销。// todo pipline
```
    > set name1 codehole
    OK
    > set name2 holycoder
    OK
    > mget name1 name2 name3 # 返回一个列表 
    1) "codehole"
    2) "holycoder"
    3) (nil)
    > mset name1 boy name2 girl name3 unknown 
    > mget name1 name2 name3
    1) "boy"
    2) "girl"
    3) "unknown"
```
### list 列表
列表可以用来做什么，我看敦神曾经用list存储 某个垂类的用户list。这个可以类比 Java中的linkedlist，注意是链表，不是数组，不支持 randomAccess,遍历 O(n) 的时间复杂度,不多底层也有优化，在数据量比较少的时候使用ziplist(压缩列表)。比如用户的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。
1. 常见的命令：
    rpush (进队),llen(获取队列长度)，rpop
2. 快速列表 todo
在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是 压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的 时候才会改成 quicklist。
因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且 会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 `prev` 和 `next`。 
3. list可以 阻塞队列或者延迟队列
    blpop/brpop 为啥要用他们呢，因为你用其他的他会 抛出异常。

### hash 字典
hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象， hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分 获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪 费网络流量。hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符 串，需要根据实际情况再三权衡。
Redis 的字典相当于 Java 语言里面的 HashMap。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞 时，就会将碰撞的元素使用链表串接起来。
![redis hash](./images/s-redis-2.png) 

不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。

> 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容 一点点迁移到新的 hash 结构中。


### set (集合)
Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的 内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。 set 结构可以用来 存储活动发送奖品的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。

### zset (有序列表)
zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结 构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权 重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。zset 还可以用来存储视频photo，value 值是photoId，score 是他的发布时间。我们 可以对发布时间进行排序。 还可以做到范围获取。

// todo 代码


#### 跳表skiplist
![zsetskiplist](./images/zset_skip_5.png)

- skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。

- 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。

- 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。

- 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。

- 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。

- 从算法实现难度上来比较，skiplist比平衡树要简单得多。

## 分布式锁
我们了解的可以用来做分布式锁比如，zk 的临时节点，redis redlock。我们系统中有哪些应用呢。比如renz系统的 审核锁单机制，底层使用的其实就是redis 分布式锁。分布式锁早期有很多问题，不过随着版本的迭代，逐渐的进行了完善。
问题举例 ： 1. 死锁问题 -> 可以设置过期时间
           2. 锁超时问题/并发请求的问题

图片待完善

## scan
有时候需要从 Redis 实例成千上万的 key 中找出特定 前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问 题，如何从海量的 key 中找出满足特定前缀的 key 列表来?
Redis 提供了一个简单暴力的指令 keys 用来列出所有满足特定正则字符串规则的 key。
这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个缺点。 1、没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个
key 满足条件，可能就崩掉了。keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错

Redis 为了解决这个问题，它在 2.8 版本中加入了大海捞针的指令——scan。scan 相比 keys 具备有以下特点:
1、复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;
2、提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的 结果可多可少;
3、同 keys 一样，它也提供模式匹配功能; 
4、服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数; 
5、返回的结果可能会有重复，需要客户端去重复，这点非常重要; 
6、遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的; 
7、单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;


## IO线程模型
IO 的多路复用模型是 redis快的一个重要的原因。
补充图片。

## 持久化
Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制 来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的持久化机制。
Redis 的持久化机制有两种，第一种是快照，第二种是 AOF 日志。快照是一次全量备 份，AOF 日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而 AOF 日志记录的是内存数据修改的指令记录文本。AOF 日志在长期的运行过程中会 变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。 所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。

### rdb
redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，快照持久化完全交给子进 程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代 码段和数据段。这时你可以将父子进程想像成一个连体婴儿，共享身体。子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读 取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存 数据结构进行不间断的修改。
这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操 作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复 制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的， 还是进程产生时那一瞬间的数据。

```
save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```
### AOF

```
appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no      #让操作系统决定何时进行同步
```
混合持久化


## 主从同步
集群哨兵模式。
Redis 同步支持主从同步和从从同步，从从同步功能是 Redis 后续版本增加的功能，为 了减轻主库的同步负担。

### 增量同步
Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本 地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指 令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了 (偏移量)。
因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer 中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆 盖前面的内容。
### 快照同步

### 无盘复制

## 过期策略
### 过期的 key 集合
redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个 字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓 惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期 了就立即删除。定时删除是集中处理，惰性删除是零散处理。

### 从库的过期策略
从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。

LRU算法。


## 其他
1. hyperLogLog 可以统计网站的UV,底层实现 -> 
2. bloomFilter 补充链接/考虑guava /爬虫/页面推荐
3. GeoHash
4. 限流操作 -> zset的score
5. 缓存雪崩/缓存穿透/缓存一致性
![redis 不隆过滤器](./images/s-redis-3.png) 