Redis 集群，顾名思义就是使用多个 Redis 节点构成的集群，从而满足在数据量和并发数大的业务需求。

在单个 Redis 的节点实例下，存储的数据量大和高并发的情况下，内存很容易就暴涨。同时，一个 Redis 的节点，内存也是受限的，两个原因，一个是内存过大，在进行数据同步的时候，全量同步的时候会导致时间过长，会增加同步失败的风险；另一个原因就是一般的 Redis 都是部署在云服务器上的，这个也会受到CPU的使用率的影响。

所以，在面对着大数据量的时候，就会 Redis 集群的方案来管理，同时也是把这么多 Redis 实例的CPU计算能力汇集到一起，从而完成关于大数据和高并发量的的读写操作。

Codis是由我国的豌豆荚团队开源的

Codis 是一个代理中间件，用的是 GO 语言开发的，如下图，Codis 在系统的位置是这样的。

![](https://p6-ad.bytecdn.cn/large/pgc-image/c1d78e2e9ed84542847cf3bc8bd41533)

Codis分为四个部分，分别是Codis Proxy (codis-proxy)、Codis Dashboard (codis-config)、Codis Redis (codis-server)和ZooKeeper/Etcd.

Codis就是起着一个中间代理的作用，能够把所有的Redis实例当成一个来使用，在客户端操作着SDK的时候和操作Redis的时候是一样的，没有差别。

因为Codis是一个无状态的，所以可以增加多个Codis来提升QPS,同时也可以起着容灾的作用。

在Codis中，Codis会把所有的key分成1024个槽，这1024个槽对应着的就是Redis的集群，这个在Codis中是会在内存中维护着这1024个槽与Redis实例的映射关系。这个槽是可以配置，可以设置成 2048 或者是4096个。看你的Redis的节点数量有多少，偏多的话，可以设置槽多一些。

Codis中key的分配算法，先是把key进行CRC32 后，得到一个32位的数字，然后再hash%1024后得到一个余数，这个值就是这个key对应着的槽，这槽后面对应着的就是redis的实例。(可以思考一下，为什么Codis很多命令行不支持，例如KEYS操作)

> CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。由于CRC32产生校验值时源数据块的每一个bit（位）都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的CRC32值。

Codis之间的槽位同步

思考一个问题：如果这个Codis节点只在自己的内存里面维护着槽位与实例的关系,那么它的槽位信息怎么在多个实例间同步呢？

Codis把这个工作交给了ZooKeeper来管理，当Codis的Codis Dashbord 改变槽位的信息的时候，其他的Codis节点会监听到ZooKeeper的槽位变化，会及时同步过来。如图

![](https://p3-ad.bytecdn.cn/large/pgc-image/54eabd5eefe94139ab3e81f46dd0eed0)


## 迁移
1. 在迁移的时候，会在原来的Redis节点和新的Redis里都保存着迁移的槽位信息，在迁移的过程中，如果有key打进将要迁移或者正在迁移的旧槽位的时候，这个时候Codis的处理机制是，先是将这个key强制迁移到新的Redis节点中，然后再告诉Codis,下次如果有新的key的打在这个槽位中的话，那么转发到新的节点。代码策略如下：

## 牺牲
1. 不支持事务，有一些命令也不支持
2. 有proxy中专层，网络有开销 -> 增加proxy的数量
3. 单个集合的容量不支持1M，否则迁移会有卡顿感


Codis是一个代理中间件，通过内存保存着槽位和实例节点之间的映射关系,槽位间的信息同步交给ZooKeeper来管理。其中不支持事务和官方的某些命令，原因就是分布多个的Redis实例没有回滚机制和WAL,所以是不支持的




