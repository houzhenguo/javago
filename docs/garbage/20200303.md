

## Kafka

mq ： 解耦 异步 削峰

消息队列 Client A -> queue -> Client B subscription 

pub sub 发布订阅模式

Kafka scala 

Kafka 是一个分布式的消息队列。 topic partition replication

producer consumer broker kafka 集群由多个 kafka 实例组成

kafka 集群 依赖 zk保存一些 meta信息

topic partition consumer producer 

一个 topic 可以被 一个 consumber group consume ，一个 partition 只能被一个 同一个组中一个consumer

进行消费，zk注册信息

topic 可以理解为一个队列

一个topic 可以有多个 consumber group ，topic 的消息复

一个 kafka 机器就是 一个 broker ,一个集群 由多个 broker组成，一个 broker 可以容纳 多个 topic

partition ： 一个topic 可以分布在 多个 broker上，一个 topic可以分为多个 partition ，每个partion是一个
有序的队列，offset 。partition 中每个消息都有一个 在 本 partition 的 offset .

partition 存储文件都是按照 offset.kafka来命名 ，用 offset 就是方便查找。

kafka 的集群是一个 伪集群，通过 修改 配置文件，在启动的时候指定不同的配置文件进行的

broker.id
host
port 

并且配置 log.dirs 配置 kafka的数据路径。log.dir 虽然名字像是 log，但是是数据的存储的地方

broker.id 是全局唯一的不可重复的

日志过期时间，zk的地址什么的

kafka 的 备份不负责读写，只是负责备份

通过命令 ./bin/kafka-server-start.sh ./config/server.properties启动kafka实例

producer 采用 push 模式 将消息发布到 broker ，每条消息被追加到 分区，属于顺序写磁盘，效率比较高，保证了 
kafka的吞吐率。

partition : 消息发送的时候都会发送到 一个 topic ，其本质是一个目录，而topic 是一些 partition  logs组成

partition offset HW,EOL 每个partition 的消息都是有序的，生产的消息被不断的追加到 partition log

分区的原因：可以适应不同的机器，提高并行读的能力。

Producer 分区的原则：

指定了分区，直接使用
没有指定分区，指定了key，根据 key 的hash进行分区
分区和key都没有指定，轮询出要给 分区

同一个 partition 可能由多个 replication 对应 server.properties 配置中 

default.replication.factor=N

leader 一旦挂掉，需要 在 replication 中选出一个 leader 

producer 先从 zk 找到 该 partition 的leader

之后好像都不适用zk，bootstrap-server

producer 将消息发送给该 leader
leader 将日志写入 本地 log
follower 从 leader pull 消息，写入本地的log后向 leader 发送 ack.

ISR 中的 replication 的ack ，向 producer 提交 ack

ISR 通信延迟短，为什么不使用 条数，12 batch,10条的量，


broker 保存消息， 

存储方式
topic 被分成 一个或者多个 partition ,每个partition 是一个文件，文件内部存者索引和 offset开头的log文件

消息被删出 可以配置

删除旧数据，可以基于时间 基于 大小。 Kafka读取特定消息的时间复杂度是 o1 ，这里 删除 过期的文件
并不会提升 kafka的性能。

高级 API ,不需要 自行管理 offset,通过zk管理，不需要管理分区，副本情况

消费者 以 consumer group 消费者组的方式工作，由一个或者多个消费者组成一个组，
共同消费 一个 topic ，多个 消费者组 可以同时消费这个 分区。

