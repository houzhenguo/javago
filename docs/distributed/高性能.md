# 高性能涉及的技术点的轻度分享

## 前言

 本文主要整理分享一些自己在平时的工作学习中了解到的一些高性能，高并发相关的一些基础知识点，做一个系列的总结。我们平时的或多或少的听过 `线程池`，`零拷贝`，`IO多路复用`，`事件驱动`，`epoll`这些名词。我们平时用到的netty,grpc 他们背后的技术原理是什么，有哪些是常用的解决套路，是本次分享的主要目的。

 ## 线程池

 ## 进程/线程/协程
 ### 进程
 1. 单进程 造成cpu 资源单利用率低下，比如 打印的同时会阻塞读取，不能够同时玩游戏。进程，直观点说：保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。`操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位`。
 ### 线程
 2. 随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程ID、当前指令指针（PC）、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。
### 任务调度
3. 大部分操作系统（如Windows、Linux）的任务调度是采用时间片轮转的抢占式调度方式。当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。任务执行的那一小段时间叫做`时间片`，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发

### 区别总结
1）线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2）一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；

3）进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其它进程不可见；

4）线程上下文切换比进程上下文切换要快得多。

### 超线程技术
平时讲的 `双核四线程`, `四核八线程` 
超线程技术：就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术（如双核四线程）由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。

#### 程序线程-> 内核线程的模型技术
1. 一对一
        对于一对一模型来说：一个用户线程就唯一地对应一个内核线程（反过来不一定成立，一个内核线程不一定有对应的用户线程）。这样：如果CPU没有采用超线程技术（如四核四线程的计算机），一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。
        一对一模型使用户线程具有与内核线程一样的优点：一个线程因某种原因阻塞时其他线程的执行不受影响（此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现）。
        但一对一模型也有两个缺点：

            1）许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；
            2）许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。

2. 多对一
        多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。

        因此，相对一对一模型：

        1）多对一模型的线程上下文切换速度要快许多；
        2）多对一模型对用户线程的数量几乎无限制。

        但多对一模型也有两个缺点：

        1）如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；
        2）在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。

3. 多对多（在现在流行的操作系统中，大都采用多对多的模型）
            多对多模型结合了一对一模型和多对一模型的优点：将多个用户线程映射到多个内核线程上，由线程库负责在可用的可调度实体上调度用户线程。

            这使得线程的上下文切换非常快：因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。

            多对多模型的优点有：

            1）一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；
            2）多对多模型对用户线程的数量没有限制；
            3）在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。

### 协程
1. 协程：英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做“用户空间线程”，具有对内核来说不可见的特性。

        1）线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率；
        2）线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程；
        3）由于在同一个线程上，因此可以避免竞争关系而使用锁；
        4）适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。
2. 原理 

        当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑。

    这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如：Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面。

    由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。

    因此：协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。

## 总结
进程和线程的区别就是：

1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；
3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；
4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

进程和线程之间的联系就是：

1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
2）资源分配给进程，同一进程的所有线程共享该进程的所有资源；
3）处理机分给线程，即真正在处理机上运行的是线程；
4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

那么，既然有了线程，为啥还要有协程？

考虑这一样一种场景：
开发者在每个线程中只做非常轻量的操作，比如访问一个极小的文件，下载一张极小的图片，加载一段极小的文本等。但是，这样”轻量的操作“的量却非常多。
在有大量这样的轻量操作的场景下，即使可以通过使用线程池来避免创建与销毁的开销，但是线程切换的开销也会非常大，甚至于接近操作本身的开销。


对于这些场景，就非常需要一种可以减少这些开销的方式。于是，协程就应景而出，非常适合这样的场景。

![](./images/high-1.png)

## 参考
1. http://www.52im.net/thread-3357-1-1.html 深入操作系统，一文读懂进程、线程、协程